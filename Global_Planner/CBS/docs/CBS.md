# CBS
>多机规划算法
## 算法简介
CBS 是一种基于冲突的 **多机器人** 路径搜索方法。也是一种集中式的路径规划算法。

## 算法过程
CBS由两个搜索过程组成：顶层搜索和底层搜索
- 底层搜索：执行带有约束的单机规划，也就是给每一个机器人搜索出一条路径，一般使用 A* 或者 Dijkstra
- 顶层搜索：遍历底层的规划路径，检查路径之间是否有冲突，如果有冲突则施加约束重新进行底层单机规划，直到所有底层路径无冲突为止


## 定义术语
- path（路径）: 一条机器人的路径
- solution （全局路径）: 多机器人系统中所有机器人的 path 的集合
- conflict （冲突）：$conflict(a_i,a_j,v,t)$ 表示在 $t$ 时刻，机器人 $a_i,a_j$ 同时到达节点 $v$ 发生了冲突
- constraints （约束）：$constraints(a_i,v,t)$ 表示在 $t$ 时刻，$a_i$ 不能占据顶点 $v$
- constraint tree (约束树)：
  - 其实就是一棵树，树的每一个节点除了包含指向子节点的指针还包括：
    1. 约束 constraints
    2. 当前计算的全局路径 solution
    3. 全局代价 cost

![image-20240110142823087](./assets/CBS.assets/image-20240110142823087.png)

## 搜索过程



### 1 顶层搜索
- 使用约束树 (CT) 来解决底层冲突

其实就是一棵树，树的每一个节点除了包含指向子节点的指针还包括：
1. 约束
2. 当前计算的全局路径
3. 全局代价 cost

顶层搜索的核心就是生成一约束树
假设现在有一个节点 N,节点内包括：
- 当前节点的约束
- 根据当前的约束计算出来的 solutions
- 根据 solutions 计算出的全局代价 cost

要生成一个子节点 N_child
1. 遍历 solutions，搜索每个机器人的路径之间是否有冲突 conflict
   - 没冲突：找到全局最优的结果，算法结束
   - 有冲突：假设找到一个冲突 $conflict(a_i,a_j,v,t)$ ,表示在 $t$ 时刻，机器人 $a_i,a_j$ 同时到达节点 $v$ 发生了冲突

2. 解决冲突
   - 此时有两种解决方案，一种是让机器人 $a_i$ 在原地停留，机器人 $a_j$ 则继续移动
   - 转换到算法中就是两种状态转移，树节点 N 分为两个子节点，并且根据停留的情况添加约束：
     - a_i 停留：添加约束 $constraints(a_i,v,t)$ , 表示在 t 时刻，a_i 不能占据 v 点
     - a_j 停留：添加约束 $constraints(a_j,v,t)$ , 表示在 t 时刻，a_j 不能占据 v 点
     - 也就是将一个冲突 $conflict(a_i,a_j,v,t)$ 拆成了两个约束 $constraints(a_i,v,t)$ , $constraints(a_j,v,t)$

3. 生成子节点
   - 约束：每个子节点继承父结点的所有约束，然后加上对应新增的约束
   - 全局路径：根据约束使用底层搜索算法计算全局路径
   - 全局代价：根据全局路径计算全局代价



### 2 底层搜索
底层搜索理论上可以使用任意一种搜索算法，比如经典的 A* 算法。
不过这个算法除了搜索空间维度还要搜索 **时间维度** 。

也就是 **space-time A*** （spatial A*）


- 状态空间升维

原来的状态空间只包含空间坐标  $c(x,y)$
现在加上一个时间维度 $c_0(x_0,y_0,t_0)$

定义机器人在单位时间内有 5 种运动方式
- 上下左右 ：$c_1(x_*,y_*,t_0+1)$
- 原地不动 ：$c_1(x_0,y_0,t_0 +1)$


预约表表示方法（Reservation Table）：

![image-20240112203921373](./assets/CBS.assets/image-20240112203921373.png)

>图中有两个机器人（First Unit, Second Unit），他们各自有一个目标点，沿着 time 轴标记了各机器人的时空位置（ reservation ）

不过这种使用预约表的方式并不能阻止两个机器人 **面对面相撞** 的问题，
例如 机器人1 和 机器人2 在 t1 时刻分别处于 1,2 位置，他们的下一步是 2,1。此时在预约表中这两个位置都是在 t2 时刻都是空闲状态，但是如果真的这样走的话，就会在 1 和 2 中间发生二者碰撞。

- 所以本算法会禁止头对头的状态

选择一种启发函数：
- 曼哈顿距离：一般用于基于栅格地图的搜索，但是如果到达目的地的最短路径是一个迂回的路径，那么曼哈顿距离就会非常低效。
- 真实距离


合作搜索：双向搜索方式，主搜索就是正向搜索，辅助搜索则是逆向搜索（从终点向起点搜索）,也就是使用逆向搜索来求 h 值（启发距离）
>寻路由主搜索执行，使用时空A *。在主搜索探索到的每个位置，请求真实距离启发式。这就是辅助搜索进入的地方，使用的是向后的空间A *。如果该位置已经在封闭列表中，则立即返回其g值。否则，恢复向后搜索，直到请求的位置被放到闭合列表中，此时返回它的g值。


- 限制搜索深度

---



# 论文阅读

## Abstract
以往大多数解决该问题的工作都是将个体机器人视为单个"联合机器人"，然后应用A *算法的单机器人搜索变体。

CBS是一个两层的算法，没有将问题转化为单一的"联合代理"模型。
- 顶层搜索冲突树 Conﬂict Tree (CT)
- 底层执行快速的单机器人搜索，以满足高层 CT 节点所施加的约束


本文还提出了一种 MA-CBS 算法 ，是 CBS 的一种推广。

## 1 介绍
>Introduction

1. 单机器人的路径规划一般使用 A*，介绍了 A*的基本原理
2. 多机器人路径规划问题（MAPF）是由一个图和多干个机器人组成，任务是在机器人运动过程中不能发生碰撞的约束下，为所有机器人找到从起始状态到目标状态的路径，同时最小化累计成本，如时间成本等。
3. 求解 MAPF问题的算法可以分为两类：最优和次优算法。寻找 MAPF 问题的最优解是一个 NP-hard 问题，因为状态空间随着机器人数量的增长呈指数增长。次优解则是为每一个机器人快速地找到一条路径
4. 本文解决的问题是找到 MAPF 问题的最优解，传统的 MAPF 问题使用 A* 算法来解决，但是存在一个求解时间过长的问题。
5. 本文的第一部分写了当前求解 MAPF 问题的综述；第二部分介绍了一种优化求解 MAPF 的新方法：CBS算法
6. 对比了 A* 和 CBS 算法，有优势，也有不足，总体来看 CBS 在许多领域优于基于 A * 的方法以及 ICTS
7. 然后提出了 CBS 算法的推广 MA-CBS


## 2 问题定义和术语
> Problem deﬁnition and terminology


2.1 问题的输入： 
1. 有向图`G(V,E)`。图的顶点为机器人可能的位置，边为位置之间可能的转移。
2. K 个机器人标记为a1，a2 .. ak。每个 机器人 有一个起始点，和一个目标点
3. 将 时间 离散化为 时间点 。在时间点 $t_0$ ，机器人 $a_i$ 位于位置 $start_i$。

2.2 动作（actions）：
1. 在连续的 时间点 之间，每个 机器人 可以 移动到相邻的顶点 或 在当前顶点等待。

2.3 MAPF约束 (constraints):
1. 主要约束是每个顶点在某一时间 最多只能被一个 机器人 占用。
2. 不允许多个机器人同时遍历同一条边。
3. 违反上述约束的情况称之为 冲突 （conﬂict）


2.4 MAPF task：
1. MAPF 问题的解决方案是一组不冲突的路径，每一个机器人都有自己的路径序列
2. 其中机器人 ai 的路径序列是一系列 {move, wait} 操作


2.5 成本函数（Cost function）：
论文的目标是解决给定的 MAPF 实例，同时使 全局累积成本函数 最小化。

1. 总成本（sum-of-costs） 是对所有 机器人最后一次达到目标所需的时间步数的总和。
2. Makespan 是另一个常见的MAPF成本函数，它最小化 `直到最后一个机器人到达目的地` 的总时间
3. 燃料( Fuel )，对应所有 机器人 移动的总距离(相当于消耗的燃料)。其中只有移动行动会产生成本，而等待行动是免费的。
4. 此外，对不同主体也可以赋予不同的权重

2.6 分布式 vs 集中式：
1. 在分布式环境下，每个 机器人 都有自己的计算能力
2. 集中式设置假设单个中心计算能力，需要为所有 机器人 寻找解决方案。

**本文的研究范围仅限于集中式方法**

2.7 一个 MAPF 问题的样例
论文给出了一个老鼠作为机器人的例子

## 3 集中式MAPF算法综述
> Survey of centralized MAPF algorithms

采用集中式方法的 MAPF 问题可以分为三类：
1. 将 MAPF 简化为其他在计算机科学中研究的很好的问题
2. 使用 sub-optimal 来解决问题
3. 使用 optimal 来解决问题 （最优）

**本文重点是 3**


3.1 基于约化的求解器
>Reduction-based solvers


使用的这类求解器将 MAPF 归结为计算机科学中研究的其他问题。
例子包括归约为布尔可满足性(SAT)、整数线性规划(ILP)和回答集编程(ASP)。
这些方法返回最优解，并且通常是针对 **最大完工时间成本** 函数设计的。它们的效率较低，甚至不适用于 **成本函数之和** 。此外，这些算法通常只在小问题实例上具有较高的效率。在大型问题实例上，从 MAPF 实例到所需问题的转换过程具有非常大但多项式的开销，这使得这些方法效率低下。

3.2 MAPF-speciﬁc sub-optimal solvers

这类算法通常是高效的，但在某些情况下并不能保证最优性甚至完备性。常用于 机器人 数量较多且最优解难以获得时。MAPF 特有的次优求解器可以进一步划分为子类。

3.2.1 Search-based suboptimal solvers
> 基于搜索的次优解

基于搜索的求解器通常旨在提供高质量的解(接近最优)，但它们在许多情况下是不完整的。这些求解器根据它们处理代理之间冲突的方式不同而不同。基于搜索的次优算法的一个突出例子是分层协作A * (HCA* ) 。在 HCA* 中，机器人 是按照某种预定义的顺序一次规划的。

3.2.2. Rule-based suboptimal solvers
>基于规则的次优求解器


3.2.3. Hybrid solvers
>混合求解器

3.3 Optimal MAPF solvers

定义：

$b_{base}$ ：一个机器人在一个时间步长内可移动到的位置的数量。本文定义 $b_{base} = 5$， 即向上下左右四个方向移动或者在原地等待。
$b_{potential}$：k 个机器人的最大可能分支数为 $b_{potential} = {b_{base}}^k$
